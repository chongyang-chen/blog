---
title: 编写Java代码的131个建议（总结）
date: 2018-01-29 20:54:40
tags:
- Java
- 编程建议
categories:
- Java
---

1. **不要在常量和变量中出现易混淆的字母**
2. **不要让常量蜕变成变量**
3. **三元运算符的类型保持一致**
<!-- more -->
1. **不要重载带有变长参数的方法**
1. **不要让null和空值威胁到变长方法**
1. **重写变长方法也循规蹈矩**
1. **小心自增的陷阱**
1. **不要让旧语法困扰你**
1. **少用静态导入**
1. **不要在本类中覆盖静态导入的方法和变量**
1. **养成良好的习惯，显示声明UID**
1. **不要用序列化类在构造函数中为不变量赋值**
1. **不要为final变量复杂赋值**
1. **使用序列化类的私有方法解决部分属性持久化问题**
1. **不要忘记break**
1. **易变业务使用脚本语言编写**
1. **慎用动态编译**
1. **避免instanceof非预期结果**
1. **断言不是鸡肋**
1. **不要只替换一个类**
1. **用偶判断，不用奇判断**
1. **用整数类型处理货币**
1. **不要让类型默认转换**
1. **边界，边界，边界**
1. **不要让四舍五入亏了一方**
1. **小心包装类型的null值**
1. **小心包装类型的大小比较**
1. **优先使用整形池**
1. **优先选择基本类型**
1. **不要随便设置随机种子**
1. **不要在接口中写实现代码**
1. **静态变量一定要先声明后赋值**
1. **不要重写静态方法**
1. **构造函数尽量简化**
1. **不要在构造函数中初始化其他类**
1. **使用构造代码块精炼程序**
1. **构造代码块会想你所想**
1. **使用静态内部类提高封装性**
1. **使用匿名类的构造函数**
1. **匿名类的构造函数很特殊**
1. **让多重继承成为现实**
1. **让工具类不可实例化**
1. **避免对象的浅复制**
1. **推荐使用序列化实现对象的复制**
1. **重写equals方法时不要识别不出自己**
1. **equals应该考虑null值情景**
1. **在equals中使用getClass进行类型判断**
1. **重写equals方法必须重写hashcode方法**
1. **推荐重写toString方法**
1. **使用package-info类为包服务**
1. **不要主动进行垃圾回收**
1. **推荐使用String字面量复制**
1. **注意方法中传递的参数要求**
1. **正确使用StringBuffer，StringBuilder**
1. **注意字符串的位置**
1. **自由选择字符串拼接方法**
1. **推荐在复杂字符串操作中使用正则**
1. **建议使用utf编码**
1. **对字符串排序持一种宽容的态度**
1. **性能考虑，数组是首选**
1. **若有必要，使用可变数组**
1. **小心数组的浅复制**
1. **在明确的情况下，为集合指定初始容量**
1. **多种最值算法，适时选择**
1. **小心基本类型数组转换类表陷阱**
1. **asList方法产生的List对象不可更改**
1. **不同的列表选择不同的遍历方法**
1. **频繁的插入和删除使用链表**
1. **列表相等只需关心元素数据**
1. **子列表只是原列表的一个视图**
1. **推荐使用subList处理局部列表**
1. **生成子列表后不要再操作原列表**
1. **使用Comparator进行排序**
1. **不推荐使用binarySearch对列表进行检索**
1. **集合中的元素必须做到compareTo和equals同步**
1. **集合运算时使用更优雅的方式**
1. **使用shuffle打乱列表**
1. **减少HashMap中元素的数量**
1. **集合中的哈希码不要重复**
1. **多线程使用Vector和HashTable**
1. **非稳定排序推荐使用List**
1. **集合大家族**
1. **推荐使用枚举定义常量**
1. **使用构造函数协助描述枚举项**
1. **小心switch带来的空值异常**
1. **在switch的default中添加AssertionError**
1. **使用valueOf前必须进行校验**
1. **用枚举实现工厂方法模式更简洁**
1. **枚举项的数量限制在64个以内**
1. **小心注解继承**
1. **枚举和注解结合使用威力更大**
1. **注意@Override不同版本的区别**
1. **Java的泛型是类型擦出的**
1. **不能初始化泛型参数和数组**
1. **强制声明泛型的实际类型**
1. **不同场景使用不同的泛型通配符**
1. **小心泛型是不能协变和逆变的**
1. **建议采用的顺序List\<T>,List\<?>,List\<Object>**
1. **严格限定泛型类型采用多重界限**
1. **数组的真实类型必须是泛型类型的子类型**
1. **注意Class类的特殊性**
1. **适时选择getDeclaredxxx和getxxx**
1. **反射访问属性或方法时将Accessible设置为true**
1. **使用forName动态加载类文件**
1. **动态加载不适合数组**
1. **动态代理可以使代理模式更加灵活**
1. **使用反射增加装饰模式的普适性**
1. **反射让模板方法模式更强大**
1. **不要太多关注反射效率**
1. **提倡异常封装**
1. **采用异常链传递异常**
1. **受检异常尽可能转化为非受检异常**
1. **不要在finally中处理返回值**
1. **不要在构造函数中抛出异常**
1. **使用Throwable获得栈信息**
1. **异常只为异常服务**
1. **多使用异常，把性能问题放一边**
1. **不推荐重写start方法**
1. **启动线程前stop方法是不靠谱的**
1. **不使用stop方法通知线程**
1. **线程优先级只使用三个等级**
1. **使用线程异常处理器提成系统可靠性**
1. **volatile不能保证数据同步**
1. **异步运算考虑使用Callable接口**
1. **优先选择线程池**
1. **适时选择不同的线程池来实现**
1. **Lock和synchronized是不一样的**
1. **预防线程死锁**
1. **适当设置阻塞队列长度**
1. **使用CountDownLatch协调子线程**
1. **CyclicBarrier让多线程齐步走**